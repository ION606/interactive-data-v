<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Redesigned 2020 Agenda Chart (Multi-Line)</title>
		<style>
			/* basic styles for the chart container */
			#chart {
				font-family: sans-serif;
				margin: 20px;
			}

			.axis path,
			.axis line {
				stroke: #ccc;
			}

			.line {
				fill: none;
				stroke-width: 1.5px;
			}

			.tooltip {
				position: absolute;
				background: rgba(255, 255, 255, 0.9);
				padding: 6px 10px;
				border: 1px solid #aaa;
				font-size: 12px;
				pointer-events: none;
				border-radius: 3px;
				box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
				opacity: 0;
			}

			.legend-item {
				cursor: pointer;
				user-select: none;
			}

			.legend-color-box {
				width: 12px;
				height: 12px;
				display: inline-block;
				margin-right: 5px;
				vertical-align: middle;
			}

			.legend-text {
				vertical-align: middle;
			}
		</style>
	</head>
	<body>
		<div id="chart"></div>
		<div id="tooltip" class="tooltip"></div>

		<script type="module">
			import {
				select,
				scaleTime,
				scaleLinear,
				scaleOrdinal,
				axisBottom,
				axisLeft,
				line,
				curveMonotoneX,
				timeParse,
				extent,
				max,
				pointer,
				format,
				schemeCategory10,
			} from "https://cdn.skypack.dev/d3@7";

			// set up margins and dimensions
			const margin = { top: 20, right: 180, bottom: 60, left: 50 },
				width = 900 - margin.left - margin.right,
				height = 500 - margin.top - margin.bottom;

			// create svg container
			const svg = select("#chart")
				.append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", `translate(${margin.left},${margin.top})`);

			// ─────────── same raw data ───────────
			const rawData = [
				{
					date: "2019-03-01",
					"big tech": 15,
					Beto: 20,
					"LGBTQ+": 20,
					"inappropriate touching": 25,
					China: 10,
					jobs: 8,
					"reproductive rights": 12,
					taxes: 10,
					debates: 5,
					"criminal justice": 7,
					race: 8,
					horserace: 5,
					"health care": 10,
					Trump: 12,
					guns: 10,
					poverty: 0,
					immigration: 3,
					climate: 5,
					Ukraine: 0,
					impeachment: 0,
				},
				{
					date: "2019-04-01",
					"big tech": 10,
					Beto: 25,
					"LGBTQ+": 15,
					"inappropriate touching": 35,
					China: 30,
					jobs: 12,
					"reproductive rights": 18,
					taxes: 15,
					debates: 8,
					"criminal justice": 10,
					race: 12,
					horserace: 8,
					"health care": 15,
					Trump: 15,
					guns: 12,
					poverty: 5,
					immigration: 5,
					climate: 8,
					Ukraine: 0,
					impeachment: 0,
				},
				{
					date: "2019-05-01",
					"big tech": 8,
					Beto: 15,
					"LGBTQ+": 10,
					"inappropriate touching": 20,
					China: 25,
					jobs: 20,
					"reproductive rights": 25,
					taxes: 10,
					debates: 10,
					"criminal justice": 12,
					race: 15,
					horserace: 10,
					"health care": 20,
					Trump: 20,
					guns: 15,
					poverty: 8,
					immigration: 8,
					climate: 10,
					Ukraine: 5,
					impeachment: 0,
				},
				{
					date: "2019-06-01",
					"big tech": 5,
					Beto: 10,
					"LGBTQ+": 8,
					"inappropriate touching": 15,
					China: 20,
					jobs: 15,
					"reproductive rights": 22,
					taxes: 20,
					debates: 15,
					"criminal justice": 15,
					race: 15,
					horserace: 12,
					"health care": 30,
					Trump: 25,
					guns: 20,
					poverty: 10,
					immigration: 10,
					climate: 15,
					Ukraine: 8,
					impeachment: 5,
				},
				{
					date: "2019-07-01",
					"big tech": 5,
					Beto: 8,
					"LGBTQ+": 7,
					"inappropriate touching": 10,
					China: 15,
					jobs: 10,
					"reproductive rights": 20,
					taxes: 25,
					debates: 40,
					"criminal justice": 30,
					race: 50,
					horserace: 45,
					"health care": 35,
					Trump: 30,
					guns: 30,
					poverty: 15,
					immigration: 15,
					climate: 20,
					Ukraine: 10,
					impeachment: 10,
				},
				{
					date: "2019-08-01",
					"big tech": 7,
					Beto: 10,
					"LGBTQ+": 6,
					"inappropriate touching": 8,
					China: 10,
					jobs: 10,
					"reproductive rights": 15,
					taxes: 15,
					debates: 20,
					"criminal justice": 20,
					race: 35,
					horserace: 25,
					"health care": 55,
					Trump: 45,
					guns: 40,
					poverty: 50,
					immigration: 40,
					climate: 30,
					Ukraine: 25,
					impeachment: 15,
				},
				{
					date: "2019-09-01",
					"big tech": 6,
					Beto: 5,
					"LGBTQ+": 5,
					"inappropriate touching": 5,
					China: 5,
					jobs: 8,
					"reproductive rights": 12,
					taxes: 10,
					debates: 10,
					"criminal justice": 15,
					race: 20,
					horserace: 12,
					"health care": 40,
					Trump: 35,
					guns: 30,
					poverty: 30,
					immigration: 35,
					climate: 40,
					Ukraine: 45,
					impeachment: 25,
				},
			];

			// parse date strings into Date objects and cast values to numbers
			const parseDate = timeParse("%Y-%m-%d");
			rawData.forEach((d) => {
				d.date = parseDate(d.date);
				Object.keys(d).forEach((key) => {
					if (key !== "date") {
						d[key] = +d[key];
					}
				});
			});

			// list all topics (keys) exactly as in rawData
			const keys = [
				"big tech",
				"Beto",
				"LGBTQ+",
				"inappropriate touching",
				"China",
				"jobs",
				"reproductive rights",
				"taxes",
				"debates",
				"criminal justice",
				"race",
				"horserace",
				"health care",
				"Trump",
				"guns",
				"poverty",
				"immigration",
				"climate",
				"Ukraine",
				"impeachment",
			];

			// transform rawData into an array of objects, one per topic, each with array of {date, value}
			const topicData = keys.map((key) => {
				return {
					key,
					values: rawData.map((d) => ({
						date: d.date,
						value: d[key],
					})),
				};
			});

			// xScale: time scale over the full date extent
			const xScale = scaleTime()
				.domain(extent(rawData, (d) => d.date))
				.range([0, width]);

			// yScale: from 0 up to the maximum single-topic value across all dates
			const yMax = max(topicData, (t) => max(t.values, (v) => v.value));
			const yScale = scaleLinear()
				.domain([0, yMax])
				.nice()
				.range([height, 0]);

			// color palette (one distinct color per topic)
			const color = scaleOrdinal().domain(keys).range(schemeCategory10);

			// line generator (smooth curve)
			const lineGenerator = line()
				.x((d) => xScale(d.date))
				.y((d) => yScale(d.value))
				.curve(curveMonotoneX);

			// draw one <path> per topic
			const linesGroup = svg.append("g").attr("class", "lines");

			linesGroup
				.selectAll(".line-path")
				.data(topicData)
				.enter()
				.append("path")
				.attr("class", "line")
				.attr("d", (d) => lineGenerator(d.values))
				.attr("stroke", (d) => color(d.key))
				.attr("data-key", (d) => d.key);

			// draw x-axis
			svg.append("g")
				.attr("class", "axis x-axis")
				.attr("transform", `translate(0, ${height})`)
				.call(
					axisBottom(xScale).tickFormat((d) =>
						d.toLocaleDateString(undefined, {
							month: "short",
							year: "numeric",
						})
					)
				);

			// draw y-axis
			svg.append("g")
				.attr("class", "axis y-axis")
				.call(axisLeft(yScale).ticks(6).tickFormat(format("~s")));

			// axis labels
			svg.append("text")
				.attr("x", width / 2)
				.attr("y", height + 50)
				.attr("text-anchor", "middle")
				.attr("font-size", 12)
				.text("Date");

			svg.append("text")
				.attr("transform", "rotate(-90)")
				.attr("x", -height / 2)
				.attr("y", -40)
				.attr("text-anchor", "middle")
				.attr("font-size", 12)
				.text("Number of Articles");

			// draw legend on the right
			const legend = svg
				.append("g")
				.attr("class", "legend")
				.attr("transform", `translate(${width + 20}, 0)`);

			keys.forEach((key, i) => {
				const legendRow = legend
					.append("g")
					.attr("class", "legend-item")
					.attr("transform", `translate(0, ${i * 20})`)
					.on("click", () => toggleTopic(key));

				// colored box
				legendRow
					.append("rect")
					.attr("class", "legend-color-box")
					.attr("width", 12)
					.attr("height", 12)
					.attr("fill", color(key));

				// label text
				legendRow
					.append("text")
					.attr("class", "legend-text")
					.attr("x", 18)
					.attr("y", 10)
					.attr("font-size", 12)
					.text(key);
			});

			// keep track of which topics are visible
			const visibleTopics = new Set(keys);

			// toggle function: show or hide a topic line on legend click
			function toggleTopic(topic) {
				if (visibleTopics.has(topic)) {
					visibleTopics.delete(topic);
				} else {
					visibleTopics.add(topic);
				}
				updateLines();
			}

			// updateLines: redraws just the visible lines
			function updateLines() {
				const filteredData = topicData.filter((t) =>
					visibleTopics.has(t.key)
				);

				// update yScale domain if needed (optional: keep static)
				// const newYMax = max(filteredData, (t) => max(t.values, (v) => v.value));
				// yScale.domain([0, newYMax]).nice();
				// svg.select(".y-axis").transition().duration(500).call(axisLeft(yScale).ticks(6).tickFormat(format("~s")));

				// bind filtered data
				const paths = linesGroup
					.selectAll(".line-path")
					.data(filteredData, (d) => d.key);

				// remove paths for hidden topics
				paths.exit().remove();

				// add new paths for newly visible topics
				paths
					.enter()
					.append("path")
					.attr("class", "line line-path")
					.attr("d", (d) => lineGenerator(d.values))
					.attr("stroke", (d) => color(d.key))
					.attr("data-key", (d) => d.key);

				// update existing paths
				paths
					.attr("d", (d) => lineGenerator(d.values))
					.attr("stroke", (d) => color(d.key));
			}

			// tooltip behavior: show value on hover at points
			// append a transparent rect to capture mouse events
			svg.append("rect")
				.attr("class", "overlay")
				.attr("width", width)
				.attr("height", height)
				.style("fill", "none")
				.style("pointer-events", "all")
				.on("mousemove", handleMousemove)
				.on("mouseout", () => {
					select("#tooltip").style("opacity", 0);
				});

			function handleMousemove(event) {
				const [mx, my] = pointer(event);
				// find the closest date by x-coordinate
				const x0 = xScale.invert(mx);

				// for each visible topic, find the closest point
				let nearest = null;
				topicData.forEach((t) => {
					if (!visibleTopics.has(t.key)) return;
					// binary search or simple linear search since dataset is small
					for (let i = 0; i < t.values.length; i++) {
						const d = t.values[i];
						if (
							i === t.values.length - 1 ||
							(d.date <= x0 && t.values[i + 1].date > x0)
						) {
							// choose between d and next based on which is closer
							const d1 = d;
							const d2 = t.values[i + 1] || d;
							const chosen =
								Math.abs(d1.date - x0) < Math.abs(d2.date - x0)
									? d1
									: d2;
							const dist = Math.hypot(
								mx - xScale(chosen.date),
								my - yScale(chosen.value)
							);
							if (!nearest || dist < nearest.dist) {
								nearest = { topic: t.key, data: chosen, dist };
							}
							break;
						}
					}
				});

				if (nearest) {
					const tooltip = select("#tooltip");
					const month = nearest.data.date.toLocaleDateString(
						undefined,
						{
							month: "short",
							year: "numeric",
						}
					);
					tooltip
						.style("opacity", 1)
						.html(
							`<strong>topic:</strong> ${nearest.topic}<br/>
             <strong>date:</strong> ${month}<br/>
             <strong>count:</strong> ${nearest.data.value}`
						)
						.style("left", event.pageX + 15 + "px")
						.style("top", event.pageY - 28 + "px");
				}
			}
		</script>
	</body>
</html>
